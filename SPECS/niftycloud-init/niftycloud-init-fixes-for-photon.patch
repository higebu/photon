diff -uN a/garp.c b/garp.c
--- a/garp.c	1970-01-01 00:00:00.000000000 +0000
+++ b/garp.c	2015-04-27 17:17:07.605209838 +0000
@@ -0,0 +1,197 @@
+/*  garp.c - Send IPv4 Gratuitous ARP Packet
+
+    Usage Example: sudo ./garp eth0
+
+    Copyright (C) 2011-2013  P.D. Buchan (pdbuchan@yahoo.com)
+    Copyright (C) 2013       Seungwon Jeong (seungwon0@gmail.com)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// Send an IPv4 Gratuitous ARP packet via raw socket at the link layer (ethernet frame).
+// Values set for ARP request.
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>           // close()
+#include <string.h>           // strcpy, memset(), and memcpy()
+
+#include <sys/types.h>        // needed for socket(), uint8_t, uint16_t
+#include <sys/socket.h>       // needed for socket()
+#include <netinet/in.h>       // IPPROTO_RAW
+#include <netinet/ip.h>       // IP_MAXPACKET (which is 65535)
+#include <sys/ioctl.h>        // macro ioctl is defined
+#include <bits/ioctls.h>      // defines values for argument "request" of ioctl.
+#include <net/if.h>           // struct ifreq
+#include <linux/if_ether.h>   // ETH_P_ARP = 0x0806
+#include <linux/if_packet.h>  // struct sockaddr_ll (see man 7 packet)
+#include <net/ethernet.h>
+
+#include <errno.h>            // errno, perror()
+
+// Define a struct for ARP header
+typedef struct _arp_hdr arp_hdr;
+struct _arp_hdr {
+  uint16_t htype;
+  uint16_t ptype;
+  uint8_t hlen;
+  uint8_t plen;
+  uint16_t opcode;
+  uint8_t sender_mac[6];
+  uint8_t sender_ip[4];
+  uint8_t target_mac[6];
+  uint8_t target_ip[4];
+};
+
+// Define some constants.
+#define ETH_HDRLEN 14      // Ethernet header length
+#define IP4_HDRLEN 20      // IPv4 header length
+#define ARP_HDRLEN 28      // ARP header length
+#define ARPOP_REQUEST 1    // Taken from <linux/if_arp.h>
+
+int
+main (int argc, char **argv)
+{
+  char *interface;
+  int i, frame_length, sd, bytes;
+  arp_hdr arphdr;
+  uint8_t src_ip[4], src_mac[6], dst_mac[6], ether_frame[IP_MAXPACKET];
+  struct sockaddr_in *ipv4;
+  struct sockaddr_ll device;
+  struct ifreq ifr;
+
+  if (argc != 2) {
+    printf ("Usage: %s INTERFACE\n", argv[0]);
+    exit (EXIT_FAILURE);
+  }
+
+  // Interface to send packet through.
+  interface = argv[1];
+
+  // Submit request for a socket descriptor to look up interface.
+  if ((sd = socket (AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
+    perror ("socket() failed to get socket descriptor for using ioctl()");
+    exit (EXIT_FAILURE);
+  }
+
+  // Use ioctl() to look up interface name and get its IPv4 address.
+  memset (&ifr, 0, sizeof (ifr));
+  snprintf (ifr.ifr_name, sizeof (ifr.ifr_name), "%s", interface);
+  if (ioctl (sd, SIOCGIFADDR, &ifr) < 0) {
+    perror ("ioctl() failed to get source IP address");
+    return (EXIT_FAILURE);
+  }
+
+  // Copy source IP address.
+  ipv4 = (struct sockaddr_in *)&ifr.ifr_addr;
+  memcpy (src_ip, &ipv4->sin_addr, 4 * sizeof (uint8_t));
+
+  // Use ioctl() to look up interface name and get its MAC address.
+  memset (&ifr, 0, sizeof (ifr));
+  snprintf (ifr.ifr_name, sizeof (ifr.ifr_name), "%s", interface);
+  if (ioctl (sd, SIOCGIFHWADDR, &ifr) < 0) {
+    perror ("ioctl() failed to get source MAC address");
+    return (EXIT_FAILURE);
+  }
+
+  close (sd);
+
+  // Copy source MAC address.
+  memcpy (src_mac, ifr.ifr_hwaddr.sa_data, 6 * sizeof (uint8_t));
+
+  // Report source MAC address to stdout.
+  printf ("MAC address for interface %s is ", interface);
+  for (i=0; i<5; i++) {
+    printf ("%02x:", src_mac[i]);
+  }
+  printf ("%02x\n", src_mac[5]);
+
+  // Find interface index from interface name and store index in
+  // struct sockaddr_ll device, which will be used as an argument of sendto().
+  if ((device.sll_ifindex = if_nametoindex (interface)) == 0) {
+    perror ("if_nametoindex() failed to obtain interface index");
+    exit (EXIT_FAILURE);
+  }
+  printf ("Index for interface %s is %i\n", interface, device.sll_ifindex);
+
+  // Set destination MAC address: broadcast address
+  memset (dst_mac, 0xff, 6 * sizeof (uint8_t));
+
+  memcpy (&arphdr.sender_ip, src_ip, 4 * sizeof (uint8_t));
+  memcpy (&arphdr.target_ip, src_ip, 4 * sizeof (uint8_t));
+
+  // Fill out sockaddr_ll.
+  device.sll_family = AF_PACKET;
+  memcpy (device.sll_addr, src_mac, 6 * sizeof (uint8_t));
+  device.sll_halen = htons (6);
+
+  // ARP header
+
+  // Hardware type (16 bits): 1 for ethernet
+  arphdr.htype = htons (1);
+
+  // Protocol type (16 bits): 2048 for IP
+  arphdr.ptype = htons (ETH_P_IP);
+
+  // Hardware address length (8 bits): 6 bytes for MAC address
+  arphdr.hlen = 6;
+
+  // Protocol address length (8 bits): 4 bytes for IPv4 address
+  arphdr.plen = 4;
+
+  // OpCode: 1 for ARP request
+  arphdr.opcode = htons (ARPOP_REQUEST);
+
+  // Sender hardware address (48 bits): MAC address
+  memcpy (&arphdr.sender_mac, src_mac, 6 * sizeof (uint8_t));
+
+  // Target hardware address (48 bits): zero
+  memset (&arphdr.target_mac, 0, 6 * sizeof (uint8_t));
+
+  // Fill out ethernet frame header.
+
+  // Ethernet frame length = ethernet header (MAC + MAC + ethernet type) + ethernet data (ARP header)
+  frame_length = 6 + 6 + 2 + ARP_HDRLEN;
+
+  // Destination and Source MAC addresses
+  memcpy (ether_frame, dst_mac, 6 * sizeof (uint8_t));
+  memcpy (ether_frame + 6, src_mac, 6 * sizeof (uint8_t));
+
+  // Next is ethernet type code (ETH_P_ARP for ARP).
+  // http://www.iana.org/assignments/ethernet-numbers
+  ether_frame[12] = ETH_P_ARP / 256;
+  ether_frame[13] = ETH_P_ARP % 256;
+
+  // Next is ethernet frame data (ARP header).
+
+  // ARP header
+  memcpy (ether_frame + ETH_HDRLEN, &arphdr, ARP_HDRLEN * sizeof (uint8_t));
+
+  // Submit request for a raw socket descriptor.
+  if ((sd = socket (PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0) {
+    perror ("socket() failed");
+    exit (EXIT_FAILURE);
+  }
+
+  // Send ethernet frame to socket.
+  if ((bytes = sendto (sd, ether_frame, frame_length, 0, (struct sockaddr *) &device, sizeof (device))) <= 0) {
+    perror ("sendto() failed");
+    exit (EXIT_FAILURE);
+  }
+
+  // Close socket descriptor.
+  close (sd);
+
+  return (EXIT_SUCCESS);
+}
diff -uN a/Makefile b/Makefile
--- a/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ b/Makefile	2015-04-27 17:16:50.997291677 +0000
@@ -0,0 +1,11 @@
+CC = gcc
+TARGET = garp
+
+all: $(TARGET)
+
+$(TARGET): $(TARGET).c
+	$(CC) -o $(TARGET) $(TARGET).c
+
+clean:
+	$(RM) $(TARGET)
+
diff -uN a/niftycloud_init b/niftycloud_init
--- a/niftycloud_init	2013-03-11 11:33:55.000000000 +0000
+++ b/niftycloud_init	2015-04-28 12:19:08.216300241 +0000
@@ -1,103 +1,86 @@
 #!/bin/bash
-VERSION="1"
 
-VMWARE_GUESTD=""
-if [ -x /usr/sbin/vmware-guestd ]; then
-    VMWARE_GUESTD="/usr/sbin/vmware-guestd"
-elif [ -x /usr/sbin/vmtoolsd ]; then
-    VMWARE_GUESTD="/usr/sbin/vmtoolsd"
+VMTOOLSD=""
+if [ -x /usr/bin/vmtoolsd ]; then
+    VMTOOLSD="/usr/bin/vmtoolsd"
 else
     exit 1
 fi
 
-INIT=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.init' 2>&1)
+INIT=$(${VMTOOLSD} --cmd 'info-get guestinfo.init' 2>&1)
 if [ $? -ne 0 ]; then
-    echo "guestinfo.init undefined!"
-    ${VMWARE_GUESTD} --cmd 'info-set guestinfo.init_result 9999'
-    exit 1
+    echo "guestinfo.init undefined."
+    ${VMTOOLSD} --cmd 'info-set guestinfo.init_result 9999'
+    exit 0
 fi
 echo "guestinfo.init: $INIT"
 
-HOSTNAME=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.hostname' 2>&1)
-if [ $? -ne 0 ]; then
-    echo "guestinfo.hostname undefined!"
-fi
-echo "guestinfo.hostname: $HOSTNAME"
-
-SSH_AUTHORIZED_KEY=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.ssh_authorized_key' 2>&1)
-if [ $? -ne 0 ]; then
-    echo "guestinfo.ssh_authorized_key undefined!"
-    SSH_AUTHORIZED_KEY=""
-fi
-echo "guestinfo.ssh_authorized_key: $SSH_AUTHORIZED_KEY"
-
-LOG_CLEANUP=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.log_cleanup' 2>&1)
-if [ $? -ne 0 ]; then
-    echo "guestinfo.log_cleanup undefined!"
-    LOG_CLEANUP="0"
-fi
-echo "guestinfo.log_cleanup: $LOG_CLEANUP"
-
-USER_DATA=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.user_data' 2>&1)
-if [ $? -ne 0 ]; then
-    echo "guestinfo.user_data undefined!"
-    USER_DATA=""
-fi
-echo "guestinfo.user_data: $USER_DATA"
-
-## initialize os configuration.
+## Initialize os configuration.
 if [ $INIT == "1" ]; then
-    mkdir -p /root/.ssh && chmod 700 /root/.ssh
-    echo $?
+    SSH_AUTHORIZED_KEY=$(${VMTOOLSD} --cmd 'info-get guestinfo.ssh_authorized_key' 2>&1)
+    mkdir -p /root/.ssh
+    chmod 700 /root/.ssh
     echo $SSH_AUTHORIZED_KEY > /root/.ssh/authorized_keys
-    if [ ${#SSH_AUTHORIZED_KEY} -gt 0 -a -f "/root/.ssh/authorized_keys" -a -s "/root/.ssh/authorized_keys" ]; then
-        cat /root/.ssh/authorized_keys
-    else
-        echo "ERROR : Creating instance is miss, authorized_keys is null."
-        ${VMWARE_GUESTD} --cmd 'info-set guestinfo.init_result 9999'
-        exit 1
-    fi
-    echo $?
-    if [ -f /etc/sysconfig/network-scripts/ifcfg-eth2 ]; then
-        /bin/rm /etc/sysconfig/network-scripts/ifcfg-eth2
-        echo $?
+
+    LOG_CLEANUP=$(${VMTOOLSD} --cmd 'info-get guestinfo.log_cleanup' 2>&1)
+    if [ $? -ne 0 ]; then
+        echo "guestinfo.log_cleanup undefined."
+        LOG_CLEANUP="0"
     fi
-    cd /etc &&  sed -e "/^alias eth2/d" modprobe.conf > modprobe.new  && mv -f modprobe.new modprobe.conf
-    echo $?
+    echo "guestinfo.log_cleanup: $LOG_CLEANUP"
     if [ $LOG_CLEANUP == "1" ]; then
-        /bin/cp -f /dev/null /var/log/btmp && /bin/cp -f /dev/null /var/log/boot.log && /bin/cp -f /dev/null /var/log/lastlog && /bin/cp -f /dev/null /var/log/messages && /bin/cp -f /dev/null /var/log/secure && /bin/cp -f /dev/null /var/log/vmware-tools-guestd && /bin/cp -f /dev/null /var/log/wtmp && /bin/cp -f /dev/null /var/log/maillog && /bin/cp -f /dev/null /var/log/cron && /bin/cp -f /dev/null /var/log/audit/audit.log && export HISTSIZE=0
-        echo $?
-        /bin/cp -f /dev/null /var/log/btmp && /bin/rm -f /var/log/btmp.* && /bin/rm -f /var/log/boot.log.* && /bin/rm -f /var/log/lastlog.* && /bin/rm -f /var/log/messages.* && /bin/rm -f /var/log/secure.* && /bin/rm -f /var/log/vmware-tools-guestd.* && /bin/rm -f /var/log/wtmp.* && /bin/rm -f /var/log/maillog.* && /bin/rm -f /var/log/cron.* && /bin/rm -f /var/log/audit/audit.log.*
-        echo $?
+         /bin/cp -f /dev/null /var/log/btmp
+         /bin/cp -f /dev/null /var/log/lastlog
+         /bin/cp -f /dev/null /var/log/wtmp
+         /bin/rm -f /var/log/btmp.*
+         /bin/rm -f /var/log/lastlog.*
+         /bin/rm -f /var/log/wtmp.*
+         /bin/rm -f /var/log/mk-install-package.sh-*.log
+         export HISTSIZE=0
     fi
-    echo $?
 
     chmod 755 /etc/shadow
     sed -i -e "s/^root:[^:]*:/root:*NIFTYCLOUD*:/g" /etc/shadow
-    echo $?
     chmod 400 /etc/shadow
 
-    cd /etc/ssh &&  sed -e "s/^PasswordAuthentication yes/PasswordAuthentication no/" sshd_config > sshd_config.new &&echo "PermitRootLogin without-password" >> sshd_config.new && mv -f sshd_config.new sshd_config
+    sed -i "s/^PasswordAuthentication yes/PasswordAuthentication no/" /etc/ssh/sshd_config
+    sed -i "s/^PermitRootLogin no/PermitRootLogin without-password/" /etc/ssh/sshd_config
 
-    ${VMWARE_GUESTD} --cmd 'info-set guestinfo.init 0'
-    ${VMWARE_GUESTD} --cmd 'info-set guestinfo.log_cleanup 0'
+    rm -f /etc/ssh/ssh_host_*
+    ssh-keygen -A
+    systemctl restart sshd
+
+    ${VMTOOLSD} --cmd 'info-set guestinfo.init 0'
+    ${VMTOOLSD} --cmd 'info-set guestinfo.log_cleanup 0'
 fi
 
-USER_DATA_FLAG=$(${VMWARE_GUESTD} --cmd 'info-get guestinfo.set_user_data')
+USER_DATA_FLAG=$(${VMTOOLSD} --cmd 'info-get guestinfo.set_user_data')
+USER_DATA_PATH=/usr/share/niftycloud/user-data
 if [ "$USER_DATA_FLAG" == "1" ]; then
-    echo "$USER_DATA" | openssl enc -d -base64 > ~/.niftycloud_user_data
-    awk 'NR==1{print $1}' ~/.niftycloud_user_data | grep ^\#\!
-    if [ $? -eq 0 ]; then
-        tr -d "\r" < ~/.niftycloud_user_data > ~/.niftycloud_user_data1
-        mv ~/.niftycloud_user_data1 ~/.niftycloud_user_data
-        chmod 755 ~/.niftycloud_user_data
-        logger -p user.info "$(~/.niftycloud_user_data 2>&1)"
-        # logger -p user.info "execute ~/.niftycloud_user_data"
+    TMPFILE=$(mktemp /tmp/XXXXXX-user-data)
+    ${VMTOOLSD} --cmd 'info-get guestinfo.user_data' | openssl enc -d -base64 > "${TMPFILE}"
+    if [ -s "${TMPFILE}" ]; then
+        if [ `head -n1 ${TMPFILE} | grep ^\#\!` -eq 0 ]; then
+            cat ${TMPFILE} | tr -d '\r' > ${USER_DATA_PATH}
+            chmod 755 ${USER_DATA_PATH}
+            ${USER_DATA_PATH}
+        fi
     fi
-    ${VMWARE_GUESTD} --cmd 'info-set guestinfo.set_user_data 0'
+    ${VMTOOLSD} --cmd 'info-set guestinfo.set_user_data 0'
 else
-    rm -rf ~/.niftycloud_user_data
+    rm -rf ${USER_DATA_PATH}
 fi
 
-${VMWARE_GUESTD} --cmd 'info-set guestinfo.init_result 1'
-exit $?
+${VMTOOLSD} --cmd 'info-set guestinfo.init_result 1'
+
+while [ 1 ]; do
+    IP=$(ip addr show eth0 | grep "inet " | cut -d' ' -f6 | cut -d'/' -f1)
+    if [ "$IP" != "" ]; then
+        echo "eth0 Address: $IP"
+        break
+    fi
+    sleep .1
+done
+/usr/share/niftycloud/garp eth0
+
+exit 0
